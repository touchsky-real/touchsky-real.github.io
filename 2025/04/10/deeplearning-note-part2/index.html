<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>深度学习笔记(第二部分) | Touchsky's blog</title><meta name="author" content="touchsky"><meta name="copyright" content="touchsky"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="循环神经网络 (Recurrent Networks)应用场景之前 CNN 和 MLP 的输入和输出都只有一个,但实际问题中的输入和输出可能有多个。比如给图像加描述(one to many), 视频分类(many to one), 机器翻译(many to many),这些应用中可以使用循环神经网络。 当你处理的问题的输入或输出涉及到 序列 时候，可以使用循环神经网络。 循环神经网络可以对非序列型"><meta property="og:type" content="article"><meta property="og:title" content="深度学习笔记(第二部分)"><meta property="og:url" content="http://example.com/2025/04/10/deeplearning-note-part2/index.html"><meta property="og:site_name" content="Touchsky&#39;s blog"><meta property="og:description" content="循环神经网络 (Recurrent Networks)应用场景之前 CNN 和 MLP 的输入和输出都只有一个,但实际问题中的输入和输出可能有多个。比如给图像加描述(one to many), 视频分类(many to one), 机器翻译(many to many),这些应用中可以使用循环神经网络。 当你处理的问题的输入或输出涉及到 序列 时候，可以使用循环神经网络。 循环神经网络可以对非序列型"><meta property="og:locale"><meta property="og:image" content="http://example.com/img/avatar.webp"><meta property="article:published_time" content="2025-04-10T12:40:16.000Z"><meta property="article:modified_time" content="2025-04-24T13:36:49.327Z"><meta property="article:author" content="touchsky"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/avatar.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深度学习笔记(第二部分)",
  "url": "http://example.com/2025/04/10/deeplearning-note-part2/",
  "image": "http://example.com/img/avatar.webp",
  "datePublished": "2025-04-10T12:40:16.000Z",
  "dateModified": "2025-04-24T13:36:49.327Z",
  "author": [
    {
      "@type": "Person",
      "name": "touchsky",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/04/10/deeplearning-note-part2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(()=>{const e={set:(e,t,o)=>{if(!o)return;const a=Date.now()+864e5*o;localStorage.setItem(e,JSON.stringify({value:t,expiry:a}))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const{value:o,expiry:a}=JSON.parse(t);if(!(Date.now()>a))return o;localStorage.removeItem(e)}};window.btf={saveToLocal:e,getScript:(e,t={})=>new Promise((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,Object.entries(t).forEach(([e,t])=>n.setAttribute(e,t)),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),getCSS:(e,t)=>new Promise((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onload=n.onreadystatechange=()=>{n.readyState&&!/loaded|complete/.test(n.readyState)||o()},n.onerror=a,document.head.appendChild(n)}),addGlobalFn:(e,t,o=!1,a=window)=>{if(e.startsWith("pjax"))return;const n=a.globalFn||{};n[e]=n[e]||{},n[e][o||Object.keys(n[e]).length]=t,a.globalFn=n}};const t=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},o=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};btf.activateDarkMode=t,btf.activateLightMode=o;const a=e.get("theme");"dark"===a?t():"light"===a&&o();const n=e.get("aside-status");void 0!==n&&document.documentElement.classList.toggle("hide-aside","hide"===n);/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})()</script><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1,highlightFullpage:!1,highlightMacStyle:!1},copy:{success:"Copy Successful",error:"Copy Failed",noSupport:"Browser Not Supported"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"Just now",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:void 0,lightbox:"null",Snackbar:void 0,infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js",buttonText:"Load More"},isPhotoFigcaption:!1,islazyloadPlugin:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"深度学习笔记(第二部分)",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Touchsky's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">深度学习笔记(第二部分)</span></a></span><div id="menus"></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">深度学习笔记(第二部分)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-04-10T12:40:16.000Z" title="Created 2025-04-10 20:40:16">2025-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-04-24T13:36:49.327Z" title="Updated 2025-04-24 21:36:49">2025-04-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="循环神经网络-Recurrent-Networks"><a href="#循环神经网络-Recurrent-Networks" class="headerlink" title="循环神经网络 (Recurrent Networks)"></a>循环神经网络 (Recurrent Networks)</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>之前 CNN 和 MLP 的输入和输出都只有一个,但实际问题中的输入和输出可能有多个。比如给图像加描述(one to many), 视频分类(many to one), 机器翻译(many to many),这些应用中可以使用循环神经网络。<br><img src="/2025/04/10/deeplearning-note-part2/tasktype.png" alt="常见的任务种类"></p><p>当你处理的问题的输入<strong>或</strong>输出涉及到 <em><strong>序列</strong></em> 时候，可以使用循环神经网络。</p><p>循环神经网络可以对<strong>非序列型</strong>的数据比如图片进行<strong>序列化的处理</strong>。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>我们可以通过在每一个时间步应用一个递推公式来处理一系列向量$x$。<br>其中使用相同的权重矩阵$W$和状态更新函数$f_W$就可以处理任意长的序列。</p><p>在序列被处理过程中，RNN 有一个一直更新的内部状态。</p><script type="math/tex;mode=display">h_{t}=f_{W} ( h_{t-1}, x_{t} )</script><p>初始状态$h_0$被设置为全 0 或者通过学习得到。</p><p><img src="/2025/04/10/deeplearning-note-part2/RNN.png" alt="RNN"></p><h2 id="RNN-实现"><a href="#RNN-实现" class="headerlink" title="RNN 实现"></a>RNN 实现</h2><h3 id="Vanilla-RNN"><a href="#Vanilla-RNN" class="headerlink" title="Vanilla RNN"></a>Vanilla RNN</h3><p>一种 RNN 是”Vanilla RNN”。</p><script type="math/tex;mode=display">h_{t}=t a n h ( W_{h h} h_{t-1}+W_{x h} x_{t}+B_{h} )</script><p>每一步的输出$y_t$通过另一个权重矩阵和隐藏状态计算得出。</p><script type="math/tex;mode=display">y_{t}=W_{h y} h_{t}+B_{y}</script><p>Vanilla RNN 在反向传播中有两个问题：</p><ol><li>经过了 tanh 函数处理，不容易反向传播。</li><li>在对矩阵乘法反向传播时候要乘矩阵的转置，并且要乘很多次。如果矩阵最大的奇异值大于一，梯度会爆炸。如果矩阵最大的奇异值小于一，梯度会消失。</li></ol><h3 id="长短期记忆（Long-Short-Term-Memory，LSTM）"><a href="#长短期记忆（Long-Short-Term-Memory，LSTM）" class="headerlink" title="长短期记忆（Long Short-Term Memory，LSTM）"></a>长短期记忆（Long Short-Term Memory，LSTM）</h3><p>长短期记忆相较于 Vanilla RNN，每步有两个状态：<strong>单元状态</strong>和<strong>隐藏状态</strong>。<br><img src="/2025/04/10/deeplearning-note-part2/Vanillavslstm.png" alt="长短期记忆与Vanilla RNN"></p><p>LSTM 内有四个门：</p><ul><li>f 遗忘门：是否清除单元状态</li><li>i 输入门：是否写入单元</li><li>g 候选门（或更新门）：写入单元的内容有多少</li><li>o 输出门：从单元中输出多少信息</li></ul><p>通过这四个门可以计算出<strong>单元状态</strong>和<strong>隐藏状态</strong>，<strong>单元状态</strong>是 LSTM 的内部状态，通过输出门来控制在<strong>隐藏状态</strong>中显示多少<strong>单元状态</strong>的信息。</p><p><img src="/2025/04/10/deeplearning-note-part2/lstmdetail.png" alt="长短期记忆细节"></p><p>LSTM 的计算图顶部有一条方便梯度传播的“高速公路”，类似于 Resnet 的设计，便于进行优化。<br><img src="/2025/04/10/deeplearning-note-part2/lstmgradient.png" alt="LSTM梯度"></p><h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><p>还有一种 RNN 网络经常被使用，称为<strong>门控循环单元</strong>(Gated Recurrent Unit,GRU)。人们通过神经网络也预测出了很多其他 RNN 网络，但 LSTM 和 GRU 的表现通常不错。</p><h2 id="截断式时间反向传播（truncated-backpropagation-through-time）"><a href="#截断式时间反向传播（truncated-backpropagation-through-time）" class="headerlink" title="截断式时间反向传播（truncated backpropagation through time）"></a>截断式时间反向传播（truncated backpropagation through time）</h2><p>循环神经网络是在时间上传播。在整个序列上执行前向传播以计算损失，然后在整个序列上执行反向传播以计算梯度。</p><p>然而，当我们需要训练非常长的序列时，这种方法会变得非常棘手。在实际应用中，人们通常采用一种近似方法，称为<strong>截断式时间反向传播</strong>（truncated backpropagation through time）。</p><p>这种方法的做法是：只在序列的若干小片段上进行前向和反向传播，而不是在整个序列上进行。<br><img src="/2025/04/10/deeplearning-note-part2/truncatedbackprop.png" alt="截断式时间反向传播"><br>当我们处理下一段的数据时，仍然会保留来自前一段的隐藏状态，并将其传递下去。前向传播过程不会受到影响。在每一段的反向传播结束后，对权重进行一次梯度更新</p><h2 id="语言模型"><a href="#语言模型" class="headerlink" title="语言模型"></a>语言模型</h2><p>语言模型用来预测下一个字符输出什么。模型在每一步从概率分布中采样得到输出，并作为下一步的输入。</p><p>在自然语言处理（NLP）中，经常需要将离散的符号（如字母、词语）转换为计算机能处理的数值形式，最简单的方法是使用独热编码（One-hot encoding）。每个向量只有一个位置是 1，其他位置都是 0。</p><p>这些向量维度高且稀疏，当矩阵相乘时，效率很低。为了解决这些问题，可以引入<strong>嵌入层</strong>。将每个离散的符号（如一个字母）映射到一个低维稠密向量中，并通过训练学习这个映射。</p><p><img src="/2025/04/10/deeplearning-note-part2/rnnlm.png" alt="RNN语言模型"></p><h2 id="多层-RNN"><a href="#多层-RNN" class="headerlink" title="多层 RNN"></a>多层 RNN</h2><p>以上都是单层的 RNN，通过将一个 RNN 的隐藏状态作为输入传递给另一个 RNN，可以实现多层的 RNN。<br><img src="/2025/04/10/deeplearning-note-part2/mutilayerRNN.png" alt="多层RNN"></p><h2 id="RNN-类型"><a href="#RNN-类型" class="headerlink" title="RNN 类型"></a>RNN 类型</h2><h3 id="一对多："><a href="#一对多：" class="headerlink" title="一对多："></a>一对多：</h3><p><img src="/2025/04/10/deeplearning-note-part2/one2many.png" alt="one2many"></p><h3 id="多对一："><a href="#多对一：" class="headerlink" title="多对一："></a>多对一：</h3><p><img src="/2025/04/10/deeplearning-note-part2/many2one.png" alt="many2one"></p><h3 id="多对多："><a href="#多对多：" class="headerlink" title="多对多："></a>多对多：</h3><p>对于多对多的情况，我们在每一个时间步都计算一个$y_t$和对应的损失。最后，我们只需将所有时间步的损失相加，并将其作为整个网络的总损失。<br><img src="/2025/04/10/deeplearning-note-part2/many2many.png" alt="many2many"></p><h3 id="序列到序列"><a href="#序列到序列" class="headerlink" title="序列到序列"></a>序列到序列</h3><p>对于机器翻译这种序列到序列(seq2seq)、(many to many)的问题，可以将一个编码器（encoder, many to one）和一个解码器(decoder,one to many)的 RNN 接起来, 它们有各自单独的权重。</p><p>编码器:处理输入数据 $[x_1, x_2, x_3, …]$。整个输入序列的信息压缩到<strong>上下文向量</strong>(Context Vector)中，通常设为最后一个隐藏状态$h_T$。</p><p>解码器:$h_T$ 作为解码器的初始隐藏向量。 每一步的输出作为下一步的输入。第一步输入通常直接指定为 \<start \>。当 decoder 输出采样到\<end \>表示结束。</end></start></p><p><img src="/2025/04/10/deeplearning-note-part2/seq2seq.png" alt="seq2seq"></p><h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><h2 id="RNN-with-attention"><a href="#RNN-with-attention" class="headerlink" title="RNN with attention"></a>RNN with attention</h2><p><img src="/2025/04/10/deeplearning-note-part2/seq2seqprob.png" alt="序列到序列RNN模型问题"><br>在之前<a href="#序列对序列">序列到序列</a>的网络中，所有信息被压缩到<strong>上下文向量</strong>中，当输入比较长时候，这个向量不能够表示所有信息。可以将注意力机制用于这一模型,在每一步产生一个上下文向量。在每一步，解码器“注意”输入序列的不同部分。</p><p>计算过程如下：<br><img src="/2025/04/10/deeplearning-note-part2/RNNwithattention.png" alt="序列到序列RNN模型加注意力"></p><ol><li>在每一步中，使用当前解码器状态$s_{t-1}$和每一个编码器的隐藏状态，计算出每个隐藏状态的对齐分数。可以用 MLP 计算。</li><li>使用 softmax 得到概率分布，也就是注意力权重$a_{t,i}$。</li><li>这一步的上下文变量 $c<em>{t}$ 是隐藏状态 $h_i$ 的线性组合。$\begin{array} {l} {\mathbf{c</em>{t}}=\Sigma<em>{\mathbf{i}} \mathbf{a</em>{t, i}} \mathbf{h_{i}}} \ \end{array}$</li><li>在编码器中使用这个上下文变量 $c<em>{t}$ 和输入计算出解码器下一个状态$s</em>{t}$</li></ol><h2 id="CNN-with-attention"><a href="#CNN-with-attention" class="headerlink" title="CNN with attention"></a>CNN with attention</h2><p>在利用 CNN 给图片加标注时候也可以使用注意力机制，每次看图片中不同的地方。<br>使用解码器当前状态和 CNN 得到的<strong>特征图</strong>也可以计算类似的对齐分数、注意力权重。<br><img src="/2025/04/10/deeplearning-note-part2/CNNwithattention.png" alt="图片标注加注意力机制"></p><h2 id="注意力层"><a href="#注意力层" class="headerlink" title="注意力层"></a>注意力层</h2><p>可以将以上的注意力机制泛化，抽象出<strong>注意力层</strong>。<br><img src="/2025/04/10/deeplearning-note-part2/attentionlayer1.png" alt="注意力层1"></p><p>query vectors 是一系列的查询向量，是想要查找的东西。每个查询向量相当于之前解码器的一个隐藏状态。</p><p>input vectors 相当于原来编码器的所有隐藏状态。</p><p>之前使用$f_{att}$计算 query vectors 和 input vector 之间的相似性，但使用点乘效果就很好。</p><p>之后同样使用 softmax 函数计算出<strong>注意力权重</strong>后线性组合输入向量得到输出向量。</p><blockquote><p><strong>放缩</strong>：实际计算相似性时通常要以因子$\sqrt{D_Q}$放缩防止梯度消失。因为点积的值随着向量维度的增加而变得越来越大。而后续经过 softmax 处理时，会产生几乎全是 0，只有一个接近 1 的分布。这会导致梯度变得非常小。</p></blockquote><p>在整个过程中，输入向量有两个功能：</p><ol><li>与查询向量相乘得到相似分数。</li><li>与注意力权重线性组合得到输出向量。</li></ol><p><img src="/2025/04/10/deeplearning-note-part2/attentionlayer2.png" alt="注意力层2"></p><p>可以拆出两个新的向量组分别实现这两个功能。通常会将输出向量$X$与两个可学习权重矩阵$W_k$和$W_v$相乘得到 key vectors 和 value vectors 来 <strong>分别</strong> 完成功能 1 和功能 2 。</p><p>每个 Query 向量都会产生一个对应的输出向量。每个 Query 都在问“我该关注输入中的哪些部分？”，然后根据 Key/Value 得到一个“回答”——对应的输出向量。</p><h3 id="自注意力层"><a href="#自注意力层" class="headerlink" title="自注意力层"></a>自注意力层</h3><p>以上的输入是两组向量 query vectors 和 input vectors。自注意力层中只有一组 input vectors。</p><p><img src="/2025/04/10/deeplearning-note-part2/selfattentionlayer.png" alt="自注意力层"></p><p>自注意力层通过一个可学习的权重矩阵$W_Q$把 input vectors 转换为 query vectors。$W_k$和$W_v$矩阵和上面相同。</p><p>自注意力层输入一组向量，输出一组向量。但是自注意力层不知道向量间的顺序，以某种顺序互换输入向量，输出向量也会以同样顺序互换。<br><img src="/2025/04/10/deeplearning-note-part2/selfattentionlayerpermutation.png" alt="自注意力层顺序"></p><p>在某些场景中，为了能让自注意力层意识到向量间的顺序，会在输入向量中拼接 <em><strong>位置编码</strong></em> 。</p><h3 id="掩码自注意力层"><a href="#掩码自注意力层" class="headerlink" title="掩码自注意力层"></a>掩码自注意力层</h3><p>在语言模型中，比如生成一段文字时候，模型应该只能使用过去的信息，不能提前查看后面的答案。</p><p>输出向量$Y_2$,应该只能使用输入向量$X_1$和$X_2$。可以通过调整注意力权重来遮盖后面的向量。</p><p><img src="/2025/04/10/deeplearning-note-part2/maskedselfattentionlayer.png" alt="掩码自注意力层"></p><h3 id="多头自注意力层"><a href="#多头自注意力层" class="headerlink" title="多头自注意力层"></a>多头自注意力层</h3><p><img src="/2025/04/10/deeplearning-note-part2/multiheadselfattentionlayer.png" alt="多头自注意力层"></p><p>在实践中，多头自注意力层经常被使用。</p><p>对于一组输入向量，把这组向量在特征维度上拆分成$H$段，分别输入到$H$个独立的自注意力层中。每个<strong>注意力头</strong>会并行地处理信息，将输出的$H$组向量在特征维度上进行拼接，就可以得到最后的输出向量。</p><p>多头自注意力层的超参数包括模型总维度（输入/输出的向量总维度）和注意力头个数$H$。</p><h2 id="CNN-with-self-attention"><a href="#CNN-with-self-attention" class="headerlink" title="CNN with self-attention"></a>CNN with self-attention</h2><p>可以使用 CNN 结合自注意力模块处理图像。<br><img src="/2025/04/10/deeplearning-note-part2/CNNwithselfattention.png" alt="CNN with self-attention"></p><p>图像经过 CNN 处理生成<strong>特征向量的网格</strong>，将之视为之前的输入向量组可以得到<strong>输出向量</strong>。</p><p>通常会在最后加一个 1x1 的卷积并加入残差连接。</p><h2 id="序列的处理方式"><a href="#序列的处理方式" class="headerlink" title="序列的处理方式"></a>序列的处理方式</h2><p>有三种处理序列的方式。</p><ul><li>RNN<ul><li>优点：适合处理长序列。最后隐藏状态取决于整个序列。</li><li>缺点：需要依次处理，不能够并行化处理。</li></ul></li><li>一维卷积：每个输出元素是输入信号中一个局部区域与卷积核进行加权求和的结果。<ul><li>优点：易于并行化处理。</li><li>缺点： 由于感受野的存在，需要多个卷积层单个输出才能看到整个输入序列。</li></ul></li><li>自注意力机制<ul><li>优点：适合处理长序列（每个输出向量取决于<strong>所有</strong>输入向量）。易于并行化处理。</li><li>缺点：需要大量 GPU 内存。</li></ul></li></ul><p><img src="/2025/04/10/deeplearning-note-part2/waystoprocessseq.png" alt="三种序列的处理方式"></p><p>实际用神经网络处理序列时候，仅需要自注意力机制:Attention is all you need.通过 Transformer 来实现。</p><h2 id="The-Transformer"><a href="#The-Transformer" class="headerlink" title="The Transformer"></a>The Transformer</h2><h3 id="Transformer-块"><a href="#Transformer-块" class="headerlink" title="Transformer 块"></a>Transformer 块</h3><p><img src="/2025/04/10/deeplearning-note-part2/Transformerblock.png" alt="Transformer块"></p><p>Transformer 块的输入是一组向量，首先经过自注意力层处理（通常包含多个注意力头），在该过程中，所有向量相互交互，每个输出向量都会根据所有输入向量计算得出。自注意力层是 Transformer 块中唯一实现向量间交互的模块。</p><p>为了稳定训练过程并促进模型优化，自注意力层的输出会经过残差连接和层归一化。得到的向量随后输入至前馈神经网络（通常由两个全连接层和一个非线性激活函数组成），这一过程作用于每个向量独立进行，不涉及向量间的交互。</p><p>前馈层的输出同样通过残差连接与层归一化，形成该 Transformer 块的最终输出。</p><blockquote><p>输出向量个数等于输入向量个数，但维度可能改变。</p></blockquote><h3 id="Transformer-模型"><a href="#Transformer-模型" class="headerlink" title="Transformer 模型"></a>Transformer 模型</h3><p>Transformer 模型是一系列的 Transformer 块。</p><p>在论文<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">Attention is all you need</a>中编码器和解码器均由 6 个 Transformer 块构成，模型总维度为 512，自注意力层中有 6 个头。</p><h1 id="网络可视化"><a href="#网络可视化" class="headerlink" title="网络可视化"></a>网络可视化</h1><p>CNN 中的第一层卷积层可以通过 RGB 图像可视化，它通常学习边缘、颜色信息。后续层不好进行可视化。可以跳过中间的卷积层，使用最后的全连接层输出的特征向量来进行可视化。<br><img src="/2025/04/10/deeplearning-note-part2/featurevectorknn.png" alt="特征向量可视化"><br>原来对原始像素进行 KNN 分类效果很差，但是对特征向量进行 KNN 分类的话效果很好。红线右侧的图像与最左边的<strong>查询图像</strong>非常相近。</p><h2 id="维度降低"><a href="#维度降低" class="headerlink" title="维度降低"></a>维度降低</h2><p>人们很难理解高维的特征向量，因此可以使用算法在尽量保持高维结构的条件下，把向量维度降低。<br>线性的维度降低算法包括 Principal Component Analysis(PCA)</p><blockquote><p>PCA 的思想很直观, 假设我们要将 n 维特征映射到 k 维, 第一维选择原始数据中方差最大的维度, 第二维选取是与第一维正交的”平面”中方差最大的维度, 依次得到 k 维。</p></blockquote><p>非线性的维度降低算法包括 t-SNE 算法<br><img src="/2025/04/10/deeplearning-note-part2/tsne.png" alt="t-SNE"><br>这里在对 10 个数字进行分类的问题中使用 t-SNE 算法把向量维度降低到二维的情况。图中包含 10 个区域的数字。</p><h1 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h1><p>在目标检测任务中，输入一张 RGB 图像, 输出一系列检测到的目标, 预测到的每个目标包含标签以及一个边界框(bounding box)。边界框朝向通常和图像一致。</p><p>目标检测任务需要更高分辨率的图像，通常是 3*800*600。</p><h2 id="检测单个目标"><a href="#检测单个目标" class="headerlink" title="检测单个目标"></a>检测单个目标</h2><p>检测单个目标比较简单，将图片经过 CNN 处理后，对特征向量分为两路处理。一路可以使用 softmax loss 函数预测类别。另一路使用 l2 loss 预测边界框的位置。总的 loss 是两个 loss 函数的加权和。类似的这样一个模型完成多个任务，每个任务使用一个 loss 函数的情况叫做<strong>multitask loss</strong><br><img src="/2025/04/10/deeplearning-note-part2/detectsingleobject.png" alt="检测单个目标"></p><blockquote><p>Softmax Loss（通常指 Softmax + Cross-Entropy Loss）适用于分类任务。</p><script type="math/tex;mode=display">\mathrm{C r o s s E n t r o p y L o s s}=-\sum_{i=1}^{C} y_{i} \operatorname{l o g} ( \hat{y}_{i} )</script><p>其中$y_i$是真实的 one-hot 标签， $\hat{y_i}<br>$是 softmax 输出的预测概率</p><p>L2 Loss（又叫 Mean Squared Error，MSE）适用于回归任务。</p><script type="math/tex;mode=display">\mathrm{L 2 ~ L o s s}=\frac{1} {n} \sum_{i=1}^{n} ( y_{i}-\hat{y}_{i} )^{2}</script></blockquote><p>但是，图像中可能有多个目标。</p><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><p>2014 年提出的<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1311.2524">R-CNN</a>(Regions with CNN features)能够完成多目标检测的任务。<br>RCNN 中，首先通过候选区域提取算法（如 Selective Search）筛选出大概 2000 个可能包含目标的区域，再将这些区域裁剪为 224*224 固定大小的图像。对于每个区域，单独使用 CNN 计算给出分类和边界框。</p><blockquote><p>衡量模型预测边界框和真实边界框的准确度使用交并比(Intersection over Union,IoU)。将边界框的交集(预测框与基准框)面积除以并集面积得到 IoU。<br><img src="/2025/04/10/deeplearning-note-part2/iou.png" alt="交并比"><br>IoU &gt; 0.5, 还行; IoU &gt; 0.7, 挺好; IoU &gt; 0.9, 几乎完美</p></blockquote><p>在目标检测任务中，模型往往会在同一个目标的周围生成多个预测框（bounding boxes），可以通过非极大值抑制（Non-Maximum Suppression, NMS）处理。NMS 的核心目标是：在多个重叠框中，只保留得分最高的那一个，抑制其他重叠度高的框。<br><img src="/2025/04/10/deeplearning-note-part2/nms.png" alt="非极大值抑制"></p><h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><p>R-CNN 会因为做 2000 个 CNN 而很慢, 我们可以通过交换<strong>裁剪候选区域</strong>和<strong>CNN</strong>的顺序, 共享一部分计算来提高效率。</p><p><img src="/2025/04/10/deeplearning-note-part2/fastrcnn.png" alt="Fast R-CNN"></p><p>在 Fast R-CNN 中图像先通过 CNN，提取整图的特征图，然后在特征图上提取每个候选区域的特征，通过在特征图上<strong>裁剪候选区域</strong>后（通过 RoI Pooling），每个区域通过一个相对<strong>轻量</strong>的 CNN 网络处理得到结果。。</p><blockquote><p>RoI Pooling（Region of Interest Pooling）是 Fast R-CNN 引入的一种关键操作，用来从特征图中提取出固定尺寸的候选区域特征，用于后续的分类和回归。</p></blockquote><p>Fast R-CNN 的训练时间能做到 R-CNN 的 1/10, 测试时间为 1/40 左右, 但是大部分时间在算候补区域。作为深度学习的实践者，可以使用 CNN 来提出可能的候选区域。</p><h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h2><p>Faster R-CNN 引入区域候选网络(Region Proposal Network)(RPN)。<br><img src="/2025/04/10/deeplearning-note-part2/fasterrcnn.png" alt="Faster R-CNN"></p><p>RPN 先想象 backbone network 已经输出了特征图, 有一个固定大小的锚框(anchor box)在特征图上滑动, RPN 其实是在训练一个二分类问题, 即锚框是否包含一个对象。<br><img src="/2025/04/10/deeplearning-note-part2/rpn.png" alt="Region Proposal Network"></p><p>固定大小的框效果很差, 我们还要训练一种边界框变化的参数(box transforms), 把锚框变为边界框(上图黄框)。</p><blockquote><ul><li>单阶段检测器：直接在输入图像上进行类别预测和边界框回归。</li><li>两阶段检测器：先通过 Region Proposal Network 找可能是目标的区域，再精细分类和回归。</li></ul></blockquote><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><p>目标检测模型使用平均精度(mean Average Precision)(mAP)来评估,计算流程如下：</p><ol><li>在所有测试图像上运行检测器。</li><li>对于每个类别，计算平均精度（AP） ，也就是精度-召回率曲线下的面积。<ol><li>对于每个检测结果（按得分从高到低排序）。如果它与某个真实框（GT）匹配，且 IoU &gt; 0.5，否则将其标记为正例，并移除该真实框。</li><li>否则，将其标记为负例。</li><li>在精度-召回率曲线上绘制一个点。</li></ol></li><li>mAP（mean Average Precision） = 所有类别 AP 的平均值。</li></ol><blockquote><ul><li>True Positive (TP)：预测为正, 实际为正(判断正确)</li><li>True Negative (TN)：预测为负, 实际为负(判断正确)</li><li>False Positive (FP)：预测为正, 实际为负(判断错误)</li><li>False Negative (FN)：预测为负, 实际为正(判断错误)</li></ul><p><strong>准确率</strong>:</p><script type="math/tex;mode=display">\mathrm{p}=\mathrm{p r e s i c i o n}={\frac{T P} {T P+F P}},</script><p>表示在所有预测为是这一类的样本中, 有多少确实是这一类。</p><p><strong>召回率</strong>:</p><script type="math/tex;mode=display">\mathrm{p}=\mathrm{p r e s i c i o n}={\frac{T P} {T P+F P}},</script><p>表示在所有实际上是这个类的样本中, 有多少被判断出来了</p><p>如果让一个已经训练好的模型在测试集上运行一次, 准确度和召回率是确定的, 以横轴为 r, 纵轴为 p 可以画出 PR 曲线(累计形式)<br><img src="/2025/04/10/deeplearning-note-part2/prcurve.jpg" alt="PR 曲线"><br>目标是获得同时具有高准确度和召回率的分类器, 在图形上的表现是曲线与坐标轴围成的区域面积尽可能大</p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">touchsky</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/04/10/deeplearning-note-part2/">http://example.com/2025/04/10/deeplearning-note-part2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/29/deeplearning-note-part1/" title="深度学习笔记(第一部分)"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">深度学习笔记(第一部分)</div></div><div class="info-2"><div class="info-item-1">线性分类器（Linear Classifiers）线性分类器的缺点 解决方法之一：特征变换 优化（Optimization） w^{*}=\operatorname{a r g} \operatorname* {m i n}_{w} L ( w )SGD对 gradient descent 进行 Stochastic 处理，每次迭代时候抽取一批样本而不是用全部样本用于参数更新来降低算力要求。 x_{t+1}=x_{t}-\alpha\nabla f ( x_{t} )123for t in range(num_steps): dw = compute_gradient(w) w -= learning_rate * dw 问题 SGD with MomentumSGD with Momentum 是为了克服 SGD 在收敛的过程中可能会停在 局部最小值 或者 鞍点 的问题，在这些点处梯度为 0，参数无法继续更新。 通过给 SGD 一个速度，从而越过局部最小值 或者 鞍点 可以解决这些问题。 \begin{aligned} v_{t+1} &= \rho...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">touchsky</div><div class="author-info-description">学习笔记、技术问题记录</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/touchsky-real" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-Recurrent-Networks"><span class="toc-number">1.</span> <span class="toc-text">循环神经网络 (Recurrent Networks)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RNN-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">RNN 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vanilla-RNN"><span class="toc-number">1.3.1.</span> <span class="toc-text">Vanilla RNN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E7%9F%AD%E6%9C%9F%E8%AE%B0%E5%BF%86%EF%BC%88Long-Short-Term-Memory%EF%BC%8CLSTM%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">长短期记忆（Long Short-Term Memory，LSTM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">其他实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%AA%E6%96%AD%E5%BC%8F%E6%97%B6%E9%97%B4%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%EF%BC%88truncated-backpropagation-through-time%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">截断式时间反向传播（truncated backpropagation through time）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">语言模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82-RNN"><span class="toc-number">1.6.</span> <span class="toc-text">多层 RNN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RNN-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">RNN 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">一对多：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%9A"><span class="toc-number">1.7.2.</span> <span class="toc-text">多对一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%9A"><span class="toc-number">1.7.3.</span> <span class="toc-text">多对多：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%88%B0%E5%BA%8F%E5%88%97"><span class="toc-number">1.7.4.</span> <span class="toc-text">序列到序列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">注意力机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RNN-with-attention"><span class="toc-number">2.1.</span> <span class="toc-text">RNN with attention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CNN-with-attention"><span class="toc-number">2.2.</span> <span class="toc-text">CNN with attention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">注意力层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%B1%82"><span class="toc-number">2.3.1.</span> <span class="toc-text">自注意力层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A9%E7%A0%81%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%B1%82"><span class="toc-number">2.3.2.</span> <span class="toc-text">掩码自注意力层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%B4%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%B1%82"><span class="toc-number">2.3.3.</span> <span class="toc-text">多头自注意力层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CNN-with-self-attention"><span class="toc-number">2.4.</span> <span class="toc-text">CNN with self-attention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">序列的处理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Transformer"><span class="toc-number">2.6.</span> <span class="toc-text">The Transformer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transformer-%E5%9D%97"><span class="toc-number">2.6.1.</span> <span class="toc-text">Transformer 块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transformer-%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">Transformer 模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">网络可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%B4%E5%BA%A6%E9%99%8D%E4%BD%8E"><span class="toc-number">3.1.</span> <span class="toc-text">维度降低</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B"><span class="toc-number">4.</span> <span class="toc-text">目标检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%8D%95%E4%B8%AA%E7%9B%AE%E6%A0%87"><span class="toc-number">4.1.</span> <span class="toc-text">检测单个目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R-CNN"><span class="toc-number">4.2.</span> <span class="toc-text">R-CNN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fast-R-CNN"><span class="toc-number">4.3.</span> <span class="toc-text">Fast R-CNN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Faster-R-CNN"><span class="toc-number">4.4.</span> <span class="toc-text">Faster R-CNN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0"><span class="toc-number">4.5.</span> <span class="toc-text">模型评估</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/10/deeplearning-note-part2/" title="深度学习笔记(第二部分)">深度学习笔记(第二部分)</a><time datetime="2025-04-10T12:40:16.000Z" title="Created 2025-04-10 20:40:16">2025-04-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/29/deeplearning-note-part1/" title="深度学习笔记(第一部分)">深度学习笔记(第一部分)</a><time datetime="2025-03-29T12:59:13.000Z" title="Created 2025-03-29 20:59:13">2025-03-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By touchsky</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(()=>{const t=()=>{if(window.MathJax)MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typesetPromise();else{window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],tags:"none"},chtml:{scale:1.1},options:{enableMenu:!0,renderActions:{findScript:[10,t=>{for(const e of document.querySelectorAll('script[type^="math/tex"]')){const n=!!e.type.match(/; *mode=display/),a=new t.options.MathItem(e.textContent,t.inputJax[0],n),d=document.createTextNode("");e.parentNode.replaceChild(d,e),a.start={node:d,delim:"",n:0},a.end={node:d,delim:"",n:0},t.math.push(a)}},""]}}};const t=document.createElement("script");t.src="https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js",t.id="MathJax-script",t.async=!0,document.head.appendChild(t)}};btf.addGlobalFn("encrypt",t,"mathjax"),window.pjax?t():window.addEventListener("load",t)})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>